package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"go/format"
	"os"
)

// This file generates golang bindings

type (
	Api struct {
		Version string            `json:"version"`
		Enums   map[string]Enum   `json:"enums"`
		Structs map[string]Struct `json:"structs"`
		Exports []Export          `json:"exports"`
	}
	Enum struct {
		Type   string         `json:"type"`
		Values map[string]int `json:"values"`
	}
	Struct []string
	Export struct {
		Namespace string     `json:"namespace"`
		Functions []Function `json:"functions"`
	}
	Function struct {
		Name string   `json:"name"`
		Args []string `json:"args"`
		Rets []string `json:"rets"`
	}
)

var api Api

var apiTypeMap = map[string]string{
	"i32":    "int32",
	"u32":    "uint32",
	"f32":    "float32",
	"bool":   "bool",
	"string": "string",
}

func printType(buf *bytes.Buffer, t string) {
	if st, isStruct := api.Structs[t]; isStruct {
		alias, hasAlias := apiTypeMap[t]
		if hasAlias {
			buf.WriteString(alias)
		} else {
			for si, apiT := range st {
				t, ok := apiTypeMap[apiT]
				if !ok {
					panic("unknown type: " + apiT)
				}

				buf.WriteString(t)

				if si < len(st)-1 {
					buf.WriteString(", ")
				}
			}
		}
	} else if _, isEnum := api.Enums[t]; isEnum {
		buf.WriteString(t)
	} else {
		t, ok := apiTypeMap[t]
		if !ok {
			panic("unknown type: " + t)
		}

		buf.WriteString(t)
	}
}

func main() {
	fmt.Println("generating bindings...")

	src, err := os.ReadFile("../../engine_api.json")
	if err != nil {
		panic(err)
	}

	err = json.Unmarshal(src, &api)
	if err != nil {
		panic(err)
	}

	var buf bytes.Buffer
	buf.WriteString("// Code generated by 'go run generate.go'; DO NOT EDIT.\n")
	buf.WriteString("package brutengine_go\n")

	// Generate enums
	fmt.Fprintf(&buf, "// Enums\n\n")
	for name, e := range api.Enums {
		goT := apiTypeMap[e.Type]
		apiTypeMap[name] = goT

		fmt.Fprintf(&buf, "type %s %s\n", name, goT)

		if len(e.Values) > 0 {
			buf.WriteString("const (\n")

			for field, value := range e.Values {
				fmt.Fprintf(&buf, "\t%s%s %s = %d\n", name, field, name, value)
			}

			buf.WriteString(")\n")
		}

		buf.WriteByte('\n')
	}

	// Generate structs
	fmt.Fprintf(&buf, "// Structs\n\n")
	for name, s := range api.Structs {
		if name == "string" {
			continue
		}

		fmt.Fprintf(&buf, "type %s struct {\n", name)

		firstLetter := name[0]
		for i, t := range s {
			fmt.Fprintf(&buf, "%c%d ", firstLetter, i+1)
			printType(&buf, t)
			buf.WriteByte('\n')
		}

		buf.WriteString("}\n\n")
	}

	for _, export := range api.Exports {
		fmt.Fprintf(&buf, "// %s Api\n", export.Namespace)

		for _, fn := range export.Functions {
			fmt.Fprintf(&buf, "//go:export %s%s\n", export.Namespace, fn.Name)
			fmt.Fprintf(&buf, "func %s%s(", export.Namespace, fn.Name)

			// Function arguments
			for i, arg := range fn.Args {
				printType(&buf, arg)
				if i < len(fn.Args)-1 {
					buf.WriteString(", ")
				}
			}

			buf.WriteString(")")

			// Function returns
			if len(fn.Rets) > 0 {
				buf.WriteString(" (")

				for i, ret := range fn.Rets {
					printType(&buf, ret)
					if i < len(fn.Rets)-1 {
						buf.WriteString(", ")
					}
				}

				buf.WriteString(")")
			}

			buf.WriteByte('\n')
		}

		buf.WriteString("\n\n")
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		panic(err)
	}

	err = os.WriteFile("../brutengine.go", formatted, os.ModePerm)
	if err != nil {
		panic(err)
	}

	fmt.Println("done!")
}
