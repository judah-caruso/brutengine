package main

import "core:fmt"
import "core:unicode"
import "core:odin/format"
import "core:strings"
import "core:os"
import "core:encoding/json"

Api :: struct {
	version: string `json:"version"`,
	enums:   map[string]Enum `json:"enums"`,
	structs: map[string]Struct `json:"structs"`,
	exports: []Export `json:"exports"`,
}

Enum :: struct {
	type:   string `json:"type"`,
	values: map[string]int `json:"values"`,
}

Struct :: []string

Export :: struct {
	namespace: string `json:"namespace"`,
	functions: []Function `json:"functions"`,
}

Function :: struct {
	name: string `json:"name"`,
	args: []string `json:"args"`,
	rets: []string `json:"rets"`,
}

api: Api

main :: proc() {
	file, ok := os.read_entire_file("../../engine_api.json")
	if !ok {
		panic("unable to read file!")
	}

	err := json.unmarshal(file, &api)
	if err != nil {
		fmt.panicf("unable to unmarshal json! %v", err)
	}

	buf: strings.Builder
	strings.write_string(&buf, "// Code generated by 'odin run generate.odin -file'; DO NOT EDIT.\n")
	strings.write_string(&buf, "package brutengine_odin\n\n")

	// Generate enums
	strings.write_string(&buf, "// Enums & Types\n\n")
	for name, def in api.enums {
      // Handle alias types
      if len(def.values) == 0 {
         fmt.sbprintf(&buf, "%s :: %s\n\n", name, def.type)
         continue
      }

		fmt.sbprintf(&buf, "%s :: enum %s {{\n", name, def.type)

		for name, value in def.values {
			fmt.sbprintf(&buf, "\t%s = %d,\n", name, value)
		}

		strings.write_string(&buf, "}\n\n")
	}

   // Generate structs
   strings.write_string(&buf, "// Structs\n\n")
   for name, fields in api.structs {
      if name == "string" do continue

      fmt.sbprintf(&buf, "%s :: struct {{\n", name)

      first := unicode.to_lower(rune(name[0]))
      for t, i in fields {
         fmt.sbprintf(&buf, "\t%r%d: %s,\n", first, i + 1, t)
      }

      strings.write_string(&buf, "}\n\n")
   }

   // Generate functions
   strings.write_string(&buf, `// Functions

foreign import env "env"

@(default_calling_convention="contextless")
foreign env {
`)

   for exp, i in api.exports {
      for fn in exp.functions {
         fmt.sbprintf(&buf, "\t%s%s :: proc(", exp.namespace, fn.name)

         for arg, i in fn.args {
            strings.write_string(&buf, arg)
            if i < len(fn.args) - 1 {
               strings.write_string(&buf, ", ")
            }
         }

         strings.write_string(&buf, ") ")

         if len(fn.rets) > 0 {
            strings.write_string(&buf, "-> ")

            multiple := len(fn.rets) > 1
            if multiple do strings.write_byte(&buf, '(')

            for ret, i in fn.rets {
               strings.write_string(&buf, ret)
               if i < len(fn.args) - 1 {
                  strings.write_string(&buf, ", ")
               }
            }

            if multiple do strings.write_byte(&buf, ')')
         }

         strings.write_string(&buf, " ---\n")
      }

      if i < len(api.exports) - 1 {
         strings.write_string(&buf, "\n")
      }
   }

   strings.write_string(&buf, "}\n")

   str := strings.to_string(buf)
   wok := os.write_entire_file("../bindings.odin", buf.buf[:], true)
   if !wok {
      panic("unable to create bindings.odin")
   }
}
