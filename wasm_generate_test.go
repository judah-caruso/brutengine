package main

/*
	Since go generate is pretty lame and doesn't let you define
	local generation functions, we're abusing the testing system
	to do this instead.
*/

import (
	"fmt"
	"io/fs"
	"os"
	"reflect"
	"strings"
	"testing"
)

// Generates wasm_export.go
func TestGenerateWasmApi(tt *testing.T) {
	b := strings.Builder{}

	var (
		implBuf = strings.Builder{}
		types   = map[string]reflect.Type{
			"Config":   reflect.TypeOf(config{}),
			"Platform": reflect.TypeOf(platform{}),
			"Input":    reflect.TypeOf(input{}),
			"Gfx":      reflect.TypeOf(gfx{}),
			"Asset":    reflect.TypeOf(asset{}),
		}
	)

	implBuf.WriteString(`// This ensures each api fits what wasm expects
var (
`)

	for apiName, t := range types {
		fmt.Fprintf(&b, "func export%s(b wazero.HostModuleBuilder) {\n", apiName)
		fmt.Fprintf(&implBuf, "\t_ = %s{\n", t.Name())

		for i := 0; i < t.NumField(); i++ {
			field := t.Field(i)
			if !field.IsExported() || field.Type.Kind() != reflect.Func {
				continue
			}

			name := field.Name
			export := field.Tag.Get("wasm")
			wrapper := field.Tag.Get("wrapper")

			var str string
			if len(wrapper) != 0 {
				str = fmt.Sprintf("b.NewFunctionBuilder().WithFunc(%s).Export(%q)", wrapper, export)
			} else {
				str = fmt.Sprintf("b.NewFunctionBuilder().WithFunc(%s%s).Export(%q)", apiName, name, export)
			}

			b.WriteString("\t" + str + "\n")

			fmt.Fprintf(&implBuf, "\t\t%[1]s: %[2]s%[1]s,\n", name, apiName)
		}

		fmt.Fprintf(&b, "}\n\n")
		implBuf.WriteString("\t}\n")
	}

	implBuf.WriteString(")\n")

	out := fmt.Sprintf(`// THIS FILE WAS GENERATED BY 'go generate' - DO NOT EDIT BY HAND!

package main

import (
	"github.com/tetratelabs/wazero"
)

%[2]s
%[1]s
	`, implBuf.String(), b.String())

	err := os.WriteFile("wasm_export.go", []byte(out), fs.ModePerm)
	if err != nil {
		tt.Fatal(err)
	}
}
